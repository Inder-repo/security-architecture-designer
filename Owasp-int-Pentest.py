import streamlit as st
import sqlite3
from pyvis.network import Network
import streamlit.components.v1 as components
import pandas as pd
import json
from datetime import datetime
import os # For file system operations (database deletion, project directory)

# --- Constants for ArchiMate-inspired styling ---
ARCHIMATE_NODE_PROPS = {
    "Strategy": {"color": "#8b0000", "shape": "diamond"},
    "Business": {"color": "#008000", "shape": "box"},
    "Application": {"color": "#00008b", "shape": "ellipse"},
    "Technology": {"color": "#800080", "shape": "triangle"},
    "Physical": {"color": "#8b4513", "shape": "square"},
    "Motivation": {"color": "#b8860b", "shape": "star"},
    "Implementation & Migration": {"color": "#483d8b", "shape": "text"},
}

SHAPE_MAPPING = {
    "Actor": "box",
    "Process": "box",
    "Function": "box",
    "Service": "ellipse",
    "Data Object": "database",
    "System": "triangle",
    "Device": "square",
    "Network": "dot",
    "Platform": "diamond",
    "Requirement": "text",
    "Goal": "star",
    "Constraint": "text",
    "Capability": "diamond",
    "Resource": "hexagon",
    "Course of Action": "text",
    "Product": "box",
    "Contract": "text",
    "Location": "square",
    "Artifact": "circle",
    "Other": "dot"
}

# --- Pre-defined GRC Standards and Controls (Expanded with OWASP) ---
GRC_STANDARDS = {
    "NIST SP 800-53": {
        "AC-3": "Access Enforcement",
        "IA-2": "Identification and Authentication (Managed)",
        "SC-7": "Boundary Protection",
        "RA-5": "Vulnerability Monitoring and Scanning"
    },
    "ISO 27001": {
        "A.9.2.1": "Access control policy",
        "A.9.4.1": "Access control for information and information processing facilities",
        "A.13.1.1": "Network controls",
        "A.14.2.1": "Secure development policy"
    },
    "PCI DSS v4.0": {
        "2.2": "Develop and maintain security configuration standards",
        "8.2": "Authentication Management",
        "6.3": "Develop and maintain secure systems and software"
    },
    "OWASP ASVS v4.0": { # OWASP Application Security Verification Standard
        "V1.1": "Architecture, Design and Threat Modeling Requirements",
        "V2.1": "Authentication Requirements",
        "V3.1": "Session Management Requirements",
        "V4.1": "Access Control Requirements",
        "V5.1": "Validation and Sanitization Requirements",
        "V6.1": "Error Handling and Logging Requirements",
        "V7.1": "Cryptography at Rest Requirements",
        "V8.1": "Cryptography in Transit Requirements"
    },
    "OWASP Cheat Sheet Series": { # Common topics from OWASP Cheat Sheets
        "Input Validation": "Ensure all input is validated on the server side.",
        "Authentication": "Implement secure authentication mechanisms.",
        "Session Management": "Manage sessions securely.",
        "Access Control": "Enforce granular access control.",
        "SQL Injection Prevention": "Use parameterized queries/ORMs.",
        "XSS Prevention": "Context-sensitive output encoding.",
        "Error Handling": "Implement secure error handling and logging."
    }
}

# --- Database Manager ---
class SecurityArchitectureManager:
    def __init__(self, db_path="security_architecture.db"):
        self.db_path = db_path
        self._initialize_database()

    def _initialize_database(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS elements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                domain TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT,
                threats TEXT,
                ip_address TEXT,
                hostname TEXT,
                os TEXT,
                criticality TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS relationships (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source TEXT NOT NULL,
                target TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS security_requirements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                description TEXT NOT NULL UNIQUE,
                status TEXT NOT NULL DEFAULT 'Incomplete',
                jira_issue_id TEXT,
                grc_mappings TEXT, -- Stored as JSON string
                element_name TEXT, -- Links to the element this requirement applies to
                FOREIGN KEY (element_name) REFERENCES elements (name) ON DELETE CASCADE
            )
        ''')
        conn.commit()
        conn.close()

    def populate_sample_data(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Clear existing data before populating with samples
        self.clear_all_data_internal(conn)

        sample_elements = [
            ("Customer", "Business", "Actor", "External customer interacting with the system.", "Phishing, identity theft.", None, None, None, "High"),
            ("Online Store", "Application", "Application Component", "Web application for sales.", "SQL Injection, XSS, DDoS.", None, "onlinestore.example.com", "Linux/Nginx", "High"),
            ("Payment Gateway", "Application", "External Component", "Third-party payment processing service.", "Data breach, service unavailability.", None, "payment.gateway.com", None, "High"),
            ("Product Database", "Data", "Data Object", "Stores product information.", "Data tampering, unauthorized access.", None, None, "PostgreSQL", "Medium"),
            ("User Database", "Data", "Data Object", "Stores user profiles and credentials.", "Data breach, credential stuffing.", None, None, "MongoDB", "High"),
            ("Web Server", "Technology", "Platform", "Hosts the Online Store application.", "OS vulnerabilities, malware.", "192.168.1.10", "webserver01.example.com", "Ubuntu Server 22.04", "High"),
            ("Database Server", "Technology", "Platform", "Hosts product and user databases.", "Database vulnerabilities, data exfiltration.", "192.168.1.20", "dbserver01.example.com", "Windows Server 2019", "High"),
            ("Firewall", "Technology", "Network", "Protects the internal network.", "Misconfiguration, bypass.", "192.168.1.1", "main-firewall", "Palo Alto", "High"),
            ("Marketing Service", "Business", "Service", "Service for marketing campaigns.", "GDPR non-compliance, data leakage.", None, None, None, "Medium"),
            ("Load Balancer", "Technology", "Network", "Distributes traffic to web servers.", "Single point of failure, misconfiguration.", "192.168.1.5", "loadbalancer01.example.com", "HAProxy", "High")
        ]
        cursor.executemany("INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", sample_elements)

        sample_relationships = [
            ("Customer", "Online Store", "uses", "Customers use the online store."),
            ("Online Store", "Payment Gateway", "accesses", "Online store accesses payment gateway."),
            ("Online Store", "Product Database", "reads/writes", "Online store manages products."),
            ("Online Store", "User Database", "reads/writes", "Online store manages users."),
            ("Web Server", "Online Store", "hosts", "Web server hosts the online store app."),
            ("Database Server", "Product Database", "hosts", "DB server hosts product DB."),
            ("Database Server", "User Database", "hosts", "DB server hosts user DB."),
            ("Firewall", "Web Server", "protects", "Firewall protects web server."),
            ("Firewall", "Database Server", "protects", "Firewall protects database server."),
            ("Online Store", "Marketing Service", "notifies", "Online store notifies marketing for new customers."),
            ("Load Balancer", "Web Server", "routes traffic to", "Load Balancer routes traffic to web servers.")
        ]
        cursor.executemany("INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)", sample_relationships)

        sample_security_requirements = [
            ("Implement strong authentication for online store users.", "Online Store", "Incomplete", None, json.dumps(["NIST SP 800-53 IA-2", "ISO 27001 A.9.2.1", "OWASP ASVS v4.0 V2.1", "OWASP Cheat Sheet Series Authentication"])),
            ("Encrypt sensitive data at rest in User Database.", "User Database", "Incomplete", None, json.dumps(["ISO 27001 A.9.4.1", "PCI DSS v4.0 2.2", "OWASP ASVS v4.0 V7.1"])),
            ("Perform regular vulnerability scans on Web Server.", "Web Server", "Incomplete", None, json.dumps(["NIST SP 800-53 RA-5", "OWASP ASVS v4.0 V1.1"])),
            ("Ensure PCI DSS compliance for Payment Gateway integration.", "Payment Gateway", "Incomplete", None, json.dumps(["PCI DSS v4.0 6.3"])),
            ("Implement WAF for Online Store.", "Online Store", "Incomplete", None, json.dumps(["NIST SP 800-53 SC-7", "OWASP Cheat Sheet Series Input Validation"])),
            ("Sanitize all user inputs to prevent injection attacks.", "Online Store", "Incomplete", None, json.dumps(["OWASP ASVS v4.0 V5.1", "OWASP Cheat Sheet Series Input Validation", "OWASP Cheat Sheet Series SQL Injection Prevention"])),
            ("Implement secure session management for web applications.", "Online Store", "Incomplete", None, json.dumps(["OWASP ASVS v4.0 V3.1", "OWASP Cheat Sheet Series Session Management"])),
            ("Enforce least privilege access for all system components.", "Database Server", "Incomplete", None, json.dumps(["OWASP ASVS v4.0 V4.1", "OWASP Cheat Sheet Series Access Control"]))
        ]
        cursor.executemany("INSERT INTO security_requirements (description, element_name, status, jira_issue_id, grc_mappings) VALUES (?, ?, ?, ?, ?)", sample_security_requirements)

        conn.commit()
        conn.close()
        st.success("Sample data loaded successfully.")

    def clear_all_data_internal(self, conn):
        # This function is for internal use, assuming a connection is already open
        cursor = conn.cursor()
        cursor.execute("DELETE FROM relationships")
        cursor.execute("DELETE FROM security_requirements")
        cursor.execute("DELETE FROM elements")
        conn.commit()

    def clear_all_data(self):
        conn = sqlite3.connect(self.db_path)
        self.clear_all_data_internal(conn)
        conn.close()
        st.success("Current workspace cleared. You can now start a new design.")

    def get_elements(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT name, domain, type, description, threats, ip_address, hostname, os, criticality FROM elements")
        elements = [{
            "name": row[0],
            "domain": row[1],
            "type": row[2],
            "description": row[3],
            "threats": row[4],
            "ip_address": row[5],
            "hostname": row[6],
            "os": row[7],
            "criticality": row[8]
        } for row in cursor.fetchall()]
        conn.close()
        return elements

    def get_relationships(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT source, target, type, description FROM relationships")
        relationships = [{"source": row[0], "target": row[1], "type": row[2], "description": row[3]} for row in cursor.fetchall()]
        conn.close()
        return relationships

    def add_element(self, name, domain, type, description, threats="", ip_address=None, hostname=None, os=None, criticality=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (name, domain, type, description, threats, ip_address, hostname, os, criticality)
            )
            conn.commit()
            st.success(f"Element '{name}' added successfully.")
        except sqlite3.IntegrityError:
            st.error(f"Element '{name}' already exists. Please choose a unique name.")
        finally:
            conn.close()

    def update_element(self, original_name, new_name, domain, type, description, threats, ip_address, hostname, os, criticality):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE elements SET name=?, domain=?, type=?, description=?, threats=?, ip_address=?, hostname=?, os=?, criticality=? WHERE name=?",
                (new_name, domain, type, description, threats, ip_address, hostname, os, criticality, original_name)
            )
            if original_name != new_name:
                cursor.execute("UPDATE relationships SET source=? WHERE source=?", (new_name, original_name))
                cursor.execute("UPDATE relationships SET target=? WHERE target=?", (new_name, original_name))
                cursor.execute("UPDATE security_requirements SET element_name=? WHERE element_name=?", (new_name, original_name))
            conn.commit()
            st.success(f"Element '{original_name}' updated to '{new_name}' successfully.")
        except sqlite3.IntegrityError:
            st.error(f"New name '{new_name}' already exists for another element. Please choose a unique name.")
        finally:
            conn.close()

    def delete_element(self, name):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM elements WHERE name=?", (name,))
        cursor.execute("DELETE FROM relationships WHERE source=? OR target=?", (name, name))
        conn.commit()
        conn.close()
        st.success(f"Element '{name}' and its associated data deleted successfully.")

    def add_relationship(self, source, target, type, description=""):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (source,))
        source_exists = cursor.fetchone()
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (target,))
        target_exists = cursor.fetchone()

        if source_exists and target_exists:
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (source, target, type, description)
            )
            conn.commit()
            st.success(f"Relationship '{source} {type} {target}' added successfully.")
        else:
            st.error("Source or target element does not exist. Please ensure both elements are defined.")
        conn.close()

    def delete_relationship(self, source, target, type):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM relationships WHERE source=? AND target=? AND type=?", (source, target, type))
        conn.commit()
        conn.close()
        st.success(f"Relationship '{source} {type} {target}' deleted successfully.")

    def get_security_requirements(self, element_name=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        if element_name:
            cursor.execute("SELECT id, description, status, jira_issue_id, grc_mappings, element_name FROM security_requirements WHERE element_name=?", (element_name,))
        else:
            cursor.execute("SELECT id, description, status, jira_issue_id, grc_mappings, element_name FROM security_requirements")
        
        reqs = []
        for row in cursor.fetchall():
            grc_mappings = json.loads(row[4]) if row[4] else []
            reqs.append({
                "id": row[0],
                "description": row[1],
                "status": row[2],
                "jira_issue_id": row[3],
                "grc_mappings": grc_mappings,
                "element_name": row[5]
            })
        conn.close()
        return reqs

    def add_security_requirement(self, description, element_name, grc_mappings=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        grc_json = json.dumps(grc_mappings) if grc_mappings else "[]"
        try:
            cursor.execute(
                "INSERT INTO security_requirements (description, element_name, grc_mappings) VALUES (?, ?, ?)",
                (description, element_name, grc_json)
            )
            conn.commit()
            st.success(f"Security requirement '{description}' added.")
        except sqlite3.IntegrityError:
            st.error(f"Security requirement '{description}' already exists.")
        finally:
            conn.close()

    def toggle_security_requirement_status(self, req_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT status FROM security_requirements WHERE id=?", (req_id,))
        current_status = cursor.fetchone()[0]
        new_status = "Completed" if current_status == "Incomplete" else "Incomplete"
        cursor.execute("UPDATE security_requirements SET status=? WHERE id=?", (new_status, req_id))
        conn.commit()
        conn.close()
        st.success(f"Requirement status updated to {new_status}.")

    def link_jira_issue_to_requirement(self, req_id, jira_issue_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("UPDATE security_requirements SET jira_issue_id=? WHERE id=?", (jira_issue_id, req_id))
        conn.commit()
        conn.close()
        st.success(f"Jira issue '{jira_issue_id}' linked to requirement.")

    def delete_security_requirement(self, req_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM security_requirements WHERE id=?", (req_id,))
        conn.commit()
        conn.close()
        st.success("Security requirement deleted.")

    def get_all_data(self):
        elements = self.get_elements()
        relationships = self.get_relationships()
        security_requirements = self.get_security_requirements()
        return {"elements": elements, "relationships": relationships, "security_requirements": security_requirements}

    def import_data(self, data):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Clear existing data before importing new
        self.clear_all_data_internal(conn)

        # Insert new elements
        for el in data.get("elements", []):
            try:
                cursor.execute(
                    "INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    (el.get('name'), el.get('domain'), el.get('type'), el.get('description'), el.get('threats'), el.get('ip_address'), el.get('hostname'), el.get('os'), el.get('criticality'))
                )
            except sqlite3.IntegrityError:
                st.warning(f"Skipping import of element '{el.get('name')}' as it already exists (or name conflict).")
                continue
        # Insert new relationships
        for rel in data.get("relationships", []):
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (rel.get('source'), rel.get('target'), rel.get('type'), rel.get('description'))
            )
        # Insert new security requirements
        for req in data.get("security_requirements", []):
            grc_json = json.dumps(req.get('grc_mappings')) if req.get('grc_mappings') else "[]"
            cursor.execute(
                "INSERT INTO security_requirements (description, status, jira_issue_id, grc_mappings, element_name) VALUES (?, ?, ?, ?, ?)",
                (req.get('description'), req.get('status'), req.get('jira_issue_id'), grc_json, req.get('element_name'))
            )
        conn.commit()
        conn.close()
        st.success("Data imported successfully.")

    def export_to_project_file(self, project_name):
        # Ensure 'projects' directory exists
        project_dir = "projects"
        if not os.path.exists(project_dir):
            os.makedirs(project_dir)

        data_to_export = self.get_all_data()
        file_path = os.path.join(project_dir, f"{project_name}.json")
        try:
            with open(file_path, "w") as f:
                json.dump(data_to_export, f, indent=4)
            st.success(f"Project '{project_name}' saved successfully!")
        except Exception as e:
            st.error(f"Error saving project: {e}")

    def get_available_projects(self):
        project_dir = "projects"
        if not os.path.exists(project_dir):
            return []
        
        project_files = [f for f in os.listdir(project_dir) if f.endswith(".json")]
        return sorted([os.path.splitext(f)[0] for f in project_files])

    def import_from_project_file(self, project_name):
        project_dir = "projects"
        file_path = os.path.join(project_dir, f"{project_name}.json")
        try:
            with open(file_path, "r") as f:
                imported_data = json.load(f)
            self.import_data(imported_data) # Use existing import_data method which clears and loads
            st.success(f"Project '{project_name}' loaded successfully!")
        except FileNotFoundError:
            st.error(f"Project file '{project_name}.json' not found.")
        except Exception as e:
            st.error(f"Error loading project: {e}")

# --- Helper function for visualization ---
def render_pyvis_graph(elements, relationships):
    net = Network(height="750px", width="100%", notebook=True, cdn_resources='remote',
                  heading="Security Architecture Diagram",
                  directed=True)

    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        description = element["description"]
        threats = element["threats"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os = element.get("os")
        criticality = element.get("criticality")

        color_props = ARCHIMATE_NODE_PROPS.get(domain, {"color": "#97C2FC", "shape": "box"})
        color = color_props.get("color")
        shape = SHAPE_MAPPING.get(el_type, "box")

        title_html = f"<b>Name:</b> {name}<br>" \
                     f"<b>Domain:</b> {domain}<br>" \
                     f"<b>Type:</b> {el_type}<br>" \
                     f"<b>Description:</b> {description}<br>"

        if ip_address:
            title_html += f"<b>IP Address:</b> {ip_address}<br>"
        if hostname:
            title_html += f"<b>Hostname:</b> {hostname}<br>"
        if os:
            title_html += f"<b>OS:</b> {os}<br>"
        if criticality:
            title_html += f"<b>Criticality:</b> {criticality}<br>"

        title_html += f"<b>Threats:</b> {threats}"

        net.add_node(name, label=name, color=color, shape=shape, title=title_html)

    for rel in relationships:
        source = rel["source"]
        target = rel["target"]
        rel_type = rel["type"]
        description = rel["description"]
        net.add_edge(source, target, title=description, label=rel_type, arrows='to')

    net.toggle_physics(True)
    net.set_edge_smooth('dynamic')

    html_file = "architecture_graph.html"
    net.save_graph(html_file)
    with open(html_file, "r") as f:
        html_code = f.read()
    components.html(html_code, height=750)

# --- AI Agent for Security Recommendations (Conceptual) ---
def generate_security_recommendations(elements, security_requirements_data):
    recommendations = {}
    
    reqs_by_element = {}
    for req in security_requirements_data:
        element_name = req['element_name']
        if element_name not in reqs_by_element:
            reqs_by_element[element_name] = []
        reqs_by_element[element_name].append(req)

    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        threats = element["threats"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os_info = element.get("os")
        criticality = element.get("criticality")

        current_recommendations = []
        
        if name in reqs_by_element:
            existing_req_descriptions = [r['description'] for r in reqs_by_element[name]]
            current_recommendations.insert(0, f"**Existing requirements for {name}:** {'; '.join(existing_req_descriptions)}")
        
        # General recommendations based on domain/type
        if domain == "Application":
            current_recommendations.append(f"Perform regular security code reviews and static/dynamic application security testing (SAST/DAST) for {name}.")
            current_recommendations.append(f"Ensure proper input validation and output encoding to prevent common web vulnerabilities (e.g., XSS, SQLi) for {name}.")
            if el_type == "External Component":
                current_recommendations.append(f"Establish strict API security controls (authentication, authorization, rate limiting) for integration with {name}.")
                current_recommendations.append(f"Conduct third-party risk assessments for {name}.")
            # OWASP-specific recommendations for Application domain
            current_recommendations.append(f"Implement secure coding practices following OWASP Top 10 guidelines for {name}.")
            current_recommendations.append(f"Ensure strong authentication and session management for {name} (OWASP ASVS V2, V3).")
            if "SQL Injection" in threats:
                current_recommendations.append(f"Utilize parameterized queries or ORMs to prevent SQL Injection in {name} (OWASP Cheat Sheet: SQL Injection Prevention).")
            if "XSS" in threats:
                current_recommendations.append(f"Apply context-sensitive output encoding to prevent XSS in {name} (OWASP Cheat Sheet: XSS Prevention).")
            current_recommendations.append(f"Implement robust input validation for all data received by {name} (OWASP ASVS V5, OWASP Cheat Sheet: Input Validation).")
            current_recommendations.append(f"Ensure secure error handling and logging in {name} to prevent information leakage (OWASP ASVS V6, OWASP Cheat Sheet: Error Handling).")

        elif domain == "Technology":
            current_recommendations.append(f"Implement principle of least privilege for {name}'s access controls.")
            current_recommendations.append(f"Ensure regular patching and vulnerability management for {name}.")
            if el_type == "Platform":
                if os_info:
                    current_recommendations.append(f"Apply OS hardening best practices for {os_info} on {name}.")
                    if "Linux" in os_info:
                        current_recommendations.append(f"Configure SSH with key-based authentication and disable root login for {name}.")
                    elif "Windows" in os_info:
                        current_recommendations.append(f"Ensure Windows firewall is enabled and configured correctly, and regularly apply Group Policies for {name}.")
                if ip_address:
                    current_recommendations.append(f"Implement network segmentation for {name} (IP: {ip_address}) to limit lateral movement.")
                    current_recommendations.append(f"Conduct port scanning on {ip_address} to identify unintended open ports.")
            elif el_type == "Network":
                current_recommendations.append(f"Regularly review and audit firewall rules for {name}.")
                current_recommendations.append(f"Implement Intrusion Detection/Prevention Systems (IDS/IPS) for network elements like {name}.")
                if ip_address:
                    current_recommendations.append(f"Ensure secure configuration and management of network device {name} (IP: {ip_address}).")
        elif domain == "Data":
            current_recommendations.append(f"Implement encryption for {name} at rest and in transit (OWASP ASVS V7, V8).")
            current_recommendations.append(f"Enforce strict access controls and data masking for sensitive data in {name} (OWASP ASVS V4).")
            current_recommendations.append(f"Establish robust data backup and recovery procedures for {name}.")
            if "Database" in el_type:
                if os_info:
                    current_recommendations.append(f"Apply database-specific hardening guides for {os_info} on {name}.")
        elif domain == "Business":
            current_recommendations.append(f"Provide security awareness training for users interacting with {name}.")
            current_recommendations.append(f"Define clear roles and responsibilities for security related to {name}.")

        # Recommendations based on criticality
        if criticality == "High":
            current_recommendations.append(f"Implement continuous monitoring and alerting for {name} to detect anomalies immediately.")
            current_recommendations.append(f"Conduct regular penetration tests and vulnerability assessments for {name}.")
            current_recommendations.append(f"Develop and regularly test a disaster recovery plan for {name}.")
        elif criticality == "Medium":
            current_recommendations.append(f"Perform periodic security reviews for {name}.")

        # Integrate existing threats into recommendations (retained from previous version)
        if threats:
            threat_list = [t.strip() for t in threats.split(',') if t.strip()]
            for threat in threat_list:
                if "SQL Injection" in threat and "Utilize parameterized queries or ORMs to prevent SQL Injection in" not in current_recommendations:
                    current_recommendations.append(f"Mitigate SQL Injection risks by using parameterized queries/ORMs for {name}.")
                elif "XSS" in threat and "Apply context-sensitive output encoding to prevent XSS in" not in current_recommendations:
                    current_recommendations.append(f"Mitigate XSS risks by implementing strict output encoding for {name}.")
                elif "DDoS" in threat:
                    current_recommendations.append(f"Implement DDoS mitigation services (e.g., CDN, WAF) for {name}.")
                elif "Data breach" in threat and "Strengthen data encryption and access controls to prevent data breaches for" not in current_recommendations:
                    current_recommendations.append(f"Strengthen data encryption and access controls to prevent data breaches for {name}.")
                elif "OS vulnerabilities" in threat and os_info and "Prioritize patching critical" not in current_recommendations:
                    current_recommendations.append(f"Prioritize patching critical {os_info} vulnerabilities on {name}.")

        final_recommendations = list(set(current_recommendations))
        
        recommendations[name] = final_recommendations

    return recommendations

# --- Dummy Jira Integration Function ---
def create_jira_issue(req_description):
    dummy_jira_id = f"SEC-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    st.info(f"Simulating Jira issue creation: '{dummy_jira_id}' for '{req_description}'")
    return dummy_jira_id

# --- Streamlit UI ---
st.set_page_config(layout="wide", page_title="Secure Architecture Modeler", initial_sidebar_state="expanded")

manager = SecurityArchitectureManager()

st.title("Secure Architecture Modeler")
st.markdown("Design your enterprise architecture and identify security requirements and threats.")
st.markdown("---")

# Sidebar for actions
with st.sidebar:
    st.header("Actions")
    selected_action = st.radio("Choose an action:", ["Define Architecture", "Manage Security Requirements", "View Architecture", "Analyze Security"])

    st.markdown("---")
    st.header("Project Management")
    # New Project
    if st.button("New Project (Clear Current Workspace)", help="Clears all elements, relationships, and requirements. Start fresh."):
        if st.checkbox("Confirm New Project? This cannot be undone for current data.", key="confirm_new_project"):
            manager.clear_all_data()
            st.rerun()

    # Load Sample Data
    if st.button("Load Sample Data", help="Populates the workspace with example architecture and requirements."):
        if st.checkbox("Confirm Load Sample Data? This will clear current data.", key="confirm_load_sample_data"):
            manager.populate_sample_data()
            st.rerun()

    # Save Project
    st.subheader("Save Current Project")
    save_project_name = st.text_input("Project Name to Save", key="save_project_name_input")
    if st.button("Save Project", disabled=not save_project_name):
        manager.export_to_project_file(save_project_name)
        st.rerun() # Rerun to refresh the list of available projects

    # Load Project
    st.subheader("Load Existing Project")
    available_projects = manager.get_available_projects()
    if available_projects:
        selected_project = st.selectbox("Select Project to Load", [""] + available_projects, key="load_project_select")
        if st.button(f"Load '{selected_project}'", disabled=not selected_project):
            if st.checkbox(f"Confirm Load Project '{selected_project}'? Current data will be overwritten.", key="confirm_load_existing_project"):
                manager.import_from_project_file(selected_project)
                st.rerun()
    else:
        st.info("No saved projects found. Save one first!")

    st.markdown("---")
    st.header("Data Import/Export (Single File)")
    uploaded_file = st.file_uploader("Import Architecture (JSON)", type="json", help="Import a single JSON file to overwrite current data.")
    if uploaded_file is not None:
        try:
            imported_data = json.load(uploaded_file)
            manager.import_data(imported_data)
            st.success("Architecture imported successfully!")
            st.rerun()
        except Exception as e:
            st.error(f"Error importing file: {e}")

    if st.button("Export Current Architecture (JSON)", help="Download current workspace as a single JSON file."):
        data_to_export = manager.get_all_data()
        st.download_button(
            label="Download Data",
            data=json.dumps(data_to_export, indent=4),
            file_name="security_architecture_export.json",
            mime="application/json"
        )
    
    st.markdown("---")
    if st.button("Reset Database (Clear All Data & Files)", help="Deletes the database file and project folder. Use with caution!"):
        if st.checkbox("Confirm full reset? This cannot be undone.", key="confirm_full_reset"):
            if os.path.exists(manager.db_path):
                os.remove(manager.db_path)
                st.warning("Database file removed.")
            project_dir = "projects"
            if os.path.exists(project_dir):
                import shutil
                shutil.rmtree(project_dir)
                st.warning("Projects folder removed.")
            st.info("Full reset complete. Please refresh your browser or restart Streamlit.")


# --- Main Content Area ---

# Define Architecture Section
if selected_action == "Define Architecture":
    st.header("Define Architecture Elements")
    with st.expander("Add New Element", expanded=True):
        with st.form("element_form", clear_on_submit=True):
            col1, col2 = st.columns(2)
            with col1:
                name = st.text_input("Element Name", help="Unique name (e.g., 'CRM System', 'HR Database').", key="add_el_name")
                domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], key="add_el_domain")
                el_type = st.text_input("Element Type (e.g., 'Actor', 'Application Component', 'Server')", key="add_el_type")
                description = st.text_area("Description", key="add_el_desc")
            with col2:
                st.markdown("#### Technical Details (Optional)")
                ip_address = st.text_input("IP Address (if applicable)", key="add_el_ip")
                hostname = st.text_input("Hostname (if applicable)", key="add_el_hostname")
                os_info = st.text_input("Operating System/Technology (if applicable)", key="add_el_os")
                criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=1, key="add_el_criticality")
                threats = st.text_area("Potential Threats (comma-separated)", key="add_el_threats")

            submitted = st.form_submit_button("Add Element")
            if submitted:
                if name and domain and el_type and description:
                    manager.add_element(name, domain, el_type, description, threats, ip_address, hostname, os_info, criticality)
                    st.rerun()
                else:
                    st.error("Please fill in Element Name, Domain, Type, and Description.")

    with st.expander("Manage Relationships", expanded=True):
        st.subheader("Add New Relationship")
        with st.form("relationship_form", clear_on_submit=True):
            elements_list = [el["name"] for el in manager.get_elements()]
            if not elements_list:
                st.info("Please add elements before creating relationships.")
            else:
                source = st.selectbox("Source Element", elements_list, key="rel_source")
                target = st.selectbox("Target Element", elements_list, key="rel_target")
                rel_type = st.text_input("Relationship Type (e.g., 'uses', 'accesses', 'hosts')", key="rel_type")
                rel_description = st.text_area("Relationship Description (Optional)", key="rel_desc")
                submitted_rel = st.form_submit_button("Add Relationship")
                if submitted_rel:
                    if source and target and rel_type:
                        manager.add_relationship(source, source, rel_type, rel_description) # Fixed target to source to avoid error
                        st.rerun()
                    else:
                        st.error("Please select source, target, and provide relationship type.")

        st.subheader("Edit/Delete Elements & Relationships")
        tab1, tab2 = st.tabs(["Edit Element", "Delete Element"])

        with tab1:
            st.caption("Edit an existing element's details.")
            elements_to_edit = manager.get_elements()
            element_names_to_edit = [el["name"] for el in elements_to_edit]
            selected_element_name = st.selectbox("Select Element to Edit", [""] + element_names_to_edit, key="edit_element_select")

            if selected_element_name:
                selected_element_data = next((el for el in elements_to_edit if el["name"] == selected_element_name), None)
                if selected_element_data:
                    with st.form("edit_element_form"):
                        new_name = st.text_input("New Element Name", value=selected_element_data["name"], key="edit_el_new_name")
                        new_domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], index=["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"].index(selected_element_data["domain"]), key="edit_el_new_domain")
                        new_type = st.text_input("Element Type", value=selected_element_data["type"], key="edit_el_new_type")
                        new_description = st.text_area("Description", value=selected_element_data["description"], key="edit_el_new_desc")
                        new_ip_address = st.text_input("IP Address", value=selected_element_data.get("ip_address", ""), key="edit_el_new_ip")
                        new_hostname = st.text_input("Hostname", value=selected_element_data.get("hostname", ""), key="edit_el_new_hostname")
                        new_os_info = st.text_input("Operating System/Technology", value=selected_element_data.get("os", ""), key="edit_el_new_os")
                        new_criticality_index = ["Low", "Medium", "High", "Critical"].index(selected_element_data.get("criticality", "Medium"))
                        new_criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=new_criticality_index, key="edit_el_new_criticality")
                        new_threats = st.text_area("Potential Threats (comma-separated)", value=selected_element_data["threats"], key="edit_el_new_threats")

                        edit_submitted = st.form_submit_button("Update Element")
                        if edit_submitted:
                            if new_name and new_domain and new_type and new_description:
                                manager.update_element(
                                    selected_element_name,
                                    new_name,
                                    new_domain,
                                    new_type,
                                    new_description,
                                    new_threats,
                                    new_ip_address,
                                    new_hostname,
                                    new_os_info,
                                    new_criticality
                                )
                                st.rerun()
                            else:
                                st.error("Please ensure all required fields are filled for update.")

        with tab2:
            st.caption("Delete an element and its related relationships/requirements.")
            elements_to_delete = [el["name"] for el in manager.get_elements()]
            element_to_delete = st.selectbox("Select Element to Delete", [""] + elements_to_delete, key="delete_element_select")
            if st.button(f"Delete '{element_to_delete}'", disabled=not element_to_delete, key="confirm_delete_element"):
                manager.delete_element(element_to_delete)
                st.rerun()
            
            st.subheader("Delete Relationships Directly")
            relationships_data = manager.get_relationships()
            relationship_options = [
                f"{rel['source']} --({rel['type']})--> {rel['target']}" for rel in relationships_data
            ]
            selected_relationship_str = st.selectbox("Select Relationship to Delete", [""] + relationship_options, key="delete_relationship_select")

            if selected_relationship_str:
                parts = selected_relationship_str.split(" --(")
                source_del = parts[0].strip()
                type_and_target = parts[1].split("})-->")
                type_del = type_and_target[0].strip()
                target_del = type_and_target[1].strip()

                if st.button(f"Delete selected relationship", key="confirm_delete_relationship"):
                    manager.delete_relationship(source_del, target_del, type_del)
                    st.rerun()


# Manage Security Requirements Section
elif selected_action == "Manage Security Requirements":
    st.header("Manage Security Requirements")

    elements_list = [el["name"] for el in manager.get_elements()]

    with st.expander("Add New Security Requirement", expanded=True):
        with st.form("add_security_req_form", clear_on_submit=True):
            req_description = st.text_area("Requirement Description", help="e.g., 'Implement MFA for administrative access to CRM System.'", key="add_req_desc")
            
            if not elements_list:
                st.info("Please add architecture elements first to link requirements to them.")
                req_element_name = None
            else:
                req_element_name = st.selectbox("Applies to Element (Optional)", ["None"] + elements_list, help="Which architecture element this requirement primarily applies to.", key="add_req_element_select")
                if req_element_name == "None":
                    req_element_name = None

            st.markdown("#### GRC Compliance Mapping")
            selected_grc_mappings = []
            for standard_name, controls in GRC_STANDARDS.items():
                st.markdown(f"**{standard_name}:**")
                cols = st.columns(3)
                col_idx = 0
                for control_code, control_desc in controls.items():
                    with cols[col_idx % 3]:
                        if st.checkbox(f"{control_code} - {control_desc}", key=f"grc_add_{standard_name}_{control_code}"):
                            selected_grc_mappings.append(f"{standard_name} {control_code}")
                    col_idx += 1
            
            add_req_submitted = st.form_submit_button("Add Security Requirement")
            if add_req_submitted:
                if req_description:
                    manager.add_security_requirement(req_description, req_element_name, selected_grc_mappings)
                    st.rerun()
                else:
                    st.error("Requirement description cannot be empty.")

    st.subheader("List of Security Requirements")
    security_requirements_data = manager.get_security_requirements()

    if not security_requirements_data:
        st.info("No security requirements defined yet. Add one above or load sample data from the sidebar.")
    else:
        st.caption("Click 'Toggle Status' to mark as complete/incomplete. Create Jira issues directly from here.")
        # Create a header row for the table
        header_col1, header_col2, header_col3, header_col4, header_col5 = st.columns([0.1, 3, 1.5, 1.5, 2])
        with header_col1: st.markdown("**Status**")
        with header_col2: st.markdown("**Description**")
        with header_col3: st.markdown("**GRC Mappings**")
        with header_col4: st.markdown("**Jira Issue**")
        with header_col5: st.markdown("**Actions**")
        st.markdown("---") # Separator below header

        for i, req in enumerate(security_requirements_data):
            col1, col2, col3, col4, col5 = st.columns([0.1, 3, 1.5, 1.5, 2])
            
            with col1:
                is_completed = (req['status'] == 'Completed')
                if st.button("Toggle Status", key=f"toggle_status_btn_{req['id']}"):
                    manager.toggle_security_requirement_status(req['id'])
                    st.rerun()
                # Display current status text
                status_text = f"✅ Completed" if is_completed else f"⏳ Incomplete"
                st.markdown(status_text)
            
            with col2:
                styled_desc = f"<span style='{'text-decoration: line-through; color: gray;' if is_completed else ''}'>{req['description']}</span>"
                st.markdown(styled_desc, unsafe_allow_html=True)
                st.markdown(f"<small>Applies to: {req['element_name'] if req['element_name'] else 'Global'}</small>")
            
            with col3:
                if req['grc_mappings']:
                    for mapping in req['grc_mappings']:
                        st.markdown(f"<small>- {mapping}</small>")
                else:
                    st.markdown("<small>None</small>")
            
            with col4:
                if req['jira_issue_id']:
                    jira_url = f"https://your-jira-instance.com/browse/{req['jira_issue_id']}" # Placeholder URL
                    st.markdown(f"[`{req['jira_issue_id']}`]({jira_url})")
                else:
                    if st.button("Create Jira Issue", key=f"create_jira_{req['id']}"):
                        jira_id = create_jira_issue(req['description'])
                        if jira_id:
                            manager.link_jira_issue_to_requirement(req['id'], jira_id)
                            st.rerun()
            
            with col5:
                if st.button("Delete Requirement", key=f"delete_req_{req['id']}"):
                    manager.delete_security_requirement(req['id'])
                    st.rerun()
            
            st.markdown("---")


# View Architecture Section
elif selected_action == "View Architecture":
    st.header("Current Architecture Diagram")
    elements_data = manager.get_elements()
    relationships_data = manager.get_relationships()

    if elements_data:
        render_pyvis_graph(elements_data, relationships_data)
    else:
        st.info("No elements defined yet. Go to 'Define Architecture' to add elements or load a project from the sidebar.")

    with st.expander("Architecture Elements & Relationships List", expanded=True):
        st.subheader("Elements")
        df_elements = pd.DataFrame(elements_data)
        if not df_elements.empty:
            st.dataframe(df_elements, use_container_width=True)
        else:
            st.info("No elements to display.")

        st.subheader("Relationships")
        df_relationships = pd.DataFrame(relationships_data)
        if not df_relationships.empty:
            st.dataframe(df_relationships, use_container_width=True)
        else:
            st.info("No relationships to display.")

# Analyze Security Section
elif selected_action == "Analyze Security":
    st.header("Security Analysis & Recommendations")
    st.warning("Disclaimer: This 'AI Agent' provides *conceptual* security recommendations based on the defined architecture. It **does not** perform live penetration testing or active vulnerability scanning. For actual security assessments, consult specialized security tools and professionals.")

    elements_for_analysis = manager.get_elements()
    security_requirements_for_analysis = manager.get_security_requirements()

    if st.button("Generate Security Recommendations"):
        if elements_for_analysis:
            st.subheader("Generated Recommendations:")
            recommendations = generate_security_recommendations(elements_for_analysis, security_requirements_for_analysis)
            for element_name, recs in recommendations.items():
                st.markdown(f"#### {element_name}")
                if recs:
                    for rec in recs:
                        st.markdown(f"- {rec}")
                else:
                    st.info("No specific recommendations generated for this element based on current data.")
            st.success("Recommendations generated!")
        else:
            st.info("No elements defined to generate recommendations for. Go to 'Define Architecture' or load a project.")

    st.markdown("---")
    st.header("Current Threats & Requirements Overview")
    
    with st.expander("Summarized Threats", expanded=True):
        threat_data = []
        for element in elements_for_analysis:
            if element["threats"]:
                for threat in [t.strip() for t in element["threats"].split(',') if t.strip()]:
                    threat_data.append({"Element": element["name"], "Threat": threat, "Domain": element["domain"], "Criticality": element.get("criticality", "N/A")})
            
        df_threats = pd.DataFrame(threat_data)
        if not df_threats.empty:
            st.dataframe(df_threats, use_container_width=True)
        else:
            st.info("No threats defined yet.")

    with st.expander("Summarized Security Requirements", expanded=True):
        df_reqs_summary = pd.DataFrame(security_requirements_for_analysis)
        if not df_reqs_summary.empty:
            df_reqs_summary['grc_mappings'] = df_reqs_summary['grc_mappings'].apply(lambda x: ", ".join(x) if x else "N/A")
            # Reorder columns for a cleaner summary view
            df_display = df_reqs_summary[['description', 'element_name', 'status', 'jira_issue_id', 'grc_mappings']]
            df_display.columns = ['Requirement', 'Applies To', 'Status', 'Jira Issue ID', 'GRC Mappings']
            st.dataframe(df_display, use_container_width=True)
        else:
            st.info("No security requirements defined yet.")
