import streamlit as st
import sqlite3
from pyvis.network import Network
import streamlit.components.v1 as components
import pandas as pd
import json

# --- Constants for ArchiMate-inspired styling ---
# More distinct colors and shapes
ARCHIMATE_NODE_PROPS = {
    "Strategy": {"color": "#8b0000", "shape": "diamond"}, # Darker red for Strategy
    "Business": {"color": "#008000", "shape": "box"},    # Darker green for Business
    "Application": {"color": "#00008b", "shape": "ellipse"}, # Darker blue for Application
    "Technology": {"color": "#800080", "shape": "triangle"}, # Purple for Technology
    "Physical": {"color": "#8b4513", "shape": "square"},  # Brown for Physical
    "Motivation": {"color": "#b8860b", "shape": "star"}, # Dark goldenrod for Motivation
    "Implementation & Migration": {"color": "#483d8b", "shape": "text"}, # Slate blue for I&M

    # Aspects - these might override or combine with layers based on specific element types
    # For simplicity, we mostly use layer colors, but shapes can be varied within layers
    "Active Structure": {}, # Default shape/color based on layer, maybe a specific border
    "Behavior": {},         # Default shape/color based on layer, maybe rounder corners if supported by Pyvis
    "Passive Structure": {},# Default shape/color based on layer
}

# Mapping for node shapes to distinguish aspects if needed, though colors for layers are primary
# Pyvis doesn't directly support ArchiMate's complex corner markings or inner icons without images.
# We'll use basic shapes, and colors for layers.
SHAPE_MAPPING = {
    "Actor": "box",
    "Process": "box",
    "Function": "box",
    "Service": "ellipse",
    "Data Object": "database",
    "System": "triangle",
    "Device": "square",
    "Network": "dot", # Simple dot for network
    "Platform": "diamond", # Represents infrastructure component
    "Requirement": "text",
    "Goal": "star",
    "Constraint": "text",
    "Capability": "diamond",
    "Resource": "hexagon",
    "Course of Action": "text",
    "Product": "box",
    "Contract": "text",
    "Location": "square",
    "Artifact": "circle",
    "Other": "dot" # Fallback
}

# --- Database Manager ---
class SecurityArchitectureManager:
    def __init__(self, db_path="security_architecture.db"):
        self.db_path = db_path
        self._initialize_database_and_populate_if_empty()

    def _initialize_database_and_populate_if_empty(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS elements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                domain TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT,
                security_requirements TEXT,
                threats TEXT,
                ip_address TEXT,
                hostname TEXT,
                os TEXT,
                criticality TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS relationships (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source TEXT NOT NULL,
                target TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT
            )
        ''')
        conn.commit()

        # Check if tables are empty and populate with sample data if they are
        cursor.execute("SELECT COUNT(*) FROM elements")
        if cursor.fetchone()[0] == 0:
            self._populate_sample_data(conn)
        conn.close()

    def _populate_sample_data(self, conn):
        cursor = conn.cursor()
        sample_elements = [
            ("Customer", "Business", "Actor", "External customer interacting with the system.", "Strong authentication, data privacy.", "Phishing, identity theft.", None, None, None, "High"),
            ("Online Store", "Application", "Application Component", "Web application for sales.", "Input validation, secure coding, WAF.", "SQL Injection, XSS, DDoS.", None, "onlinestore.example.com", "Linux/Nginx", "High"),
            ("Payment Gateway", "Application", "External Component", "Third-party payment processing service.", "PCI DSS compliance, API security.", "Data breach, service unavailability.", None, "payment.gateway.com", None, "High"),
            ("Product Database", "Data", "Data Object", "Stores product information.", "Encryption at rest/transit, access control.", "Data tampering, unauthorized access.", None, None, "PostgreSQL", "Medium"),
            ("User Database", "Data", "Data Object", "Stores user profiles and credentials.", "Encryption at rest/transit, strong access control, regular backups.", "Data breach, credential stuffing.", None, None, "MongoDB", "High"),
            ("Web Server", "Technology", "Platform", "Hosts the Online Store application.", "OS hardening, regular patching, firewall.", "OS vulnerabilities, malware.", "192.168.1.10", "webserver01.example.com", "Ubuntu Server 22.04", "High"),
            ("Database Server", "Technology", "Platform", "Hosts product and user databases.", "OS hardening, database encryption, network segmentation.", "Database vulnerabilities, data exfiltration.", "192.168.1.20", "dbserver01.example.com", "Windows Server 2019", "High"),
            ("Firewall", "Technology", "Network", "Protects the internal network.", "Rule hardening, regular audits, intrusion prevention.", "Misconfiguration, bypass.", "192.168.1.1", "main-firewall", "Palo Alto", "High"),
            ("Marketing Service", "Business", "Service", "Service for marketing campaigns.", "Data privacy, consent management.", "GDPR non-compliance, data leakage.", None, None, None, "Medium"),
            ("Load Balancer", "Technology", "Network", "Distributes traffic to web servers.", "DDoS protection, secure configuration.", "Single point of failure, misconfiguration.", "192.168.1.5", "loadbalancer01.example.com", "HAProxy", "High")
        ]
        cursor.executemany("INSERT INTO elements (name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", sample_elements)

        sample_relationships = [
            ("Customer", "Online Store", "uses", "Customers use the online store."),
            ("Online Store", "Payment Gateway", "accesses", "Online store accesses payment gateway."),
            ("Online Store", "Product Database", "reads/writes", "Online store manages products."),
            ("Online Store", "User Database", "reads/writes", "Online store manages users."),
            ("Web Server", "Online Store", "hosts", "Web server hosts the online store app."),
            ("Database Server", "Product Database", "hosts", "DB server hosts product DB."),
            ("Database Server", "User Database", "hosts", "DB server hosts user DB."),
            ("Firewall", "Web Server", "protects", "Firewall protects web server."),
            ("Firewall", "Database Server", "protects", "Firewall protects database server."),
            ("Online Store", "Marketing Service", "notifies", "Online store notifies marketing for new customers."),
            ("Load Balancer", "Web Server", "routes traffic to", "Load Balancer routes traffic to web servers.")
        ]
        cursor.executemany("INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)", sample_relationships)
        conn.commit()
        conn.close()


    def get_elements(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality FROM elements")
        elements = [{
            "name": row[0],
            "domain": row[1],
            "type": row[2],
            "description": row[3],
            "security_requirements": row[4],
            "threats": row[5],
            "ip_address": row[6],
            "hostname": row[7],
            "os": row[8],
            "criticality": row[9]
        } for row in cursor.fetchall()]
        conn.close()
        return elements

    def get_relationships(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT source, target, type, description FROM relationships")
        relationships = [{"source": row[0], "target": row[1], "type": row[2], "description": row[3]} for row in cursor.fetchall()]
        conn.close()
        return relationships

    def add_element(self, name, domain, type, description, security_requirements="", threats="", ip_address=None, hostname=None, os=None, criticality=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "INSERT INTO elements (name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality)
            )
            conn.commit()
            st.success(f"Element '{name}' added successfully.")
        except sqlite3.IntegrityError:
            st.error(f"Element '{name}' already exists. Please choose a unique name.")
        finally:
            conn.close()

    def update_element(self, original_name, new_name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE elements SET name=?, domain=?, type=?, description=?, security_requirements=?, threats=?, ip_address=?, hostname=?, os=?, criticality=? WHERE name=?",
                (new_name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality, original_name)
            )
            # Also update relationships if the element name changed
            if original_name != new_name:
                cursor.execute("UPDATE relationships SET source=? WHERE source=?", (new_name, original_name))
                cursor.execute("UPDATE relationships SET target=? WHERE target=?", (new_name, original_name))
            conn.commit()
            st.success(f"Element '{original_name}' updated to '{new_name}' successfully.")
        except sqlite3.IntegrityError:
            st.error(f"New name '{new_name}' already exists for another element. Please choose a unique name.")
        finally:
            conn.close()

    def delete_element(self, name):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM elements WHERE name=?", (name,))
        cursor.execute("DELETE FROM relationships WHERE source=? OR target=?", (name, name))
        conn.commit()
        conn.close()
        st.success(f"Element '{name}' and its relationships deleted successfully.")

    def add_relationship(self, source, target, type, description=""):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Check if source and target elements exist
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (source,))
        source_exists = cursor.fetchone()
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (target,))
        target_exists = cursor.fetchone()

        if source_exists and target_exists:
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (source, target, type, description)
            )
            conn.commit()
            st.success(f"Relationship '{source} {type} {target}' added successfully.")
        else:
            st.error("Source or target element does not exist. Please ensure both elements are defined.")
        conn.close()

    def delete_relationship(self, source, target, type):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM relationships WHERE source=? AND target=? AND type=?", (source, target, type))
        conn.commit()
        conn.close()
        st.success(f"Relationship '{source} {type} {target}' deleted successfully.")

    def get_all_data(self):
        elements = self.get_elements()
        relationships = self.get_relationships()
        return {"elements": elements, "relationships": relationships}

    def import_data(self, data):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Clear existing data
        cursor.execute("DELETE FROM elements")
        cursor.execute("DELETE FROM relationships")

        # Insert new elements
        for el in data.get("elements", []):
            try:
                cursor.execute(
                    "INSERT INTO elements (name, domain, type, description, security_requirements, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    (el.get('name'), el.get('domain'), el.get('type'), el.get('description'), el.get('security_requirements'), el.get('threats'), el.get('ip_address'), el.get('hostname'), el.get('os'), el.get('criticality'))
                )
            except sqlite3.IntegrityError:
                st.warning(f"Skipping import of element '{el.get('name')}' as it already exists (or name conflict).")
                continue
        # Insert new relationships
        for rel in data.get("relationships", []):
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (rel.get('source'), rel.get('target'), rel.get('type'), rel.get('description'))
            )
        conn.commit()
        conn.close()
        st.success("Data imported successfully.")

# --- Helper function for visualization ---
def render_pyvis_graph(elements, relationships):
    net = Network(height="750px", width="100%", notebook=True, cdn_resources='remote',
                  heading="Security Architecture Diagram",
                  directed=True) # Ensure arrows for directed relationships

    # Add nodes
    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        description = element["description"]
        threats = element["threats"]
        security_reqs = element["security_requirements"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os = element.get("os")
        criticality = element.get("criticality")

        color_props = ARCHIMATE_NODE_PROPS.get(domain, {"color": "#97C2FC", "shape": "box"})
        color = color_props.get("color")
        shape = SHAPE_MAPPING.get(el_type, "box") # Use specific shape, fallback to box

        title_html = f"<b>Name:</b> {name}<br>" \
                     f"<b>Domain:</b> {domain}<br>" \
                     f"<b>Type:</b> {el_type}<br>" \
                     f"<b>Description:</b> {description}<br>"

        if ip_address:
            title_html += f"<b>IP Address:</b> {ip_address}<br>"
        if hostname:
            title_html += f"<b>Hostname:</b> {hostname}<br>"
        if os:
            title_html += f"<b>OS:</b> {os}<br>"
        if criticality:
            title_html += f"<b>Criticality:</b> {criticality}<br>"

        title_html += f"<b>Threats:</b> {threats}<br>" \
                      f"<b>Security Requirements:</b> {security_reqs}"

        net.add_node(name, label=name, color=color, shape=shape, title=title_html)

    # Add edges
    for rel in relationships:
        source = rel["source"]
        target = rel["target"]
        rel_type = rel["type"]
        description = rel["description"]
        net.add_edge(source, target, title=description, label=rel_type, arrows='to')

    # Configure physics for better layout (optional, but often improves visualization)
    net.toggle_physics(True)
    net.set_edge_smooth('dynamic') # Adjusts edge curves for better readability

    # Generate HTML and display
    html_file = "architecture_graph.html"
    net.save_graph(html_file)
    with open(html_file, "r") as f:
        html_code = f.read()
    components.html(html_code, height=750)

# --- AI Agent for Security Recommendations (Conceptual) ---
def generate_security_recommendations(elements):
    recommendations = {}
    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        existing_reqs = element["security_requirements"]
        threats = element["threats"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os_info = element.get("os")
        criticality = element.get("criticality")

        current_recommendations = []

        # General recommendations based on domain/type
        if domain == "Application":
            current_recommendations.append(f"Perform regular security code reviews and static/dynamic application security testing (SAST/DAST) for {name}.")
            current_recommendations.append(f"Ensure proper input validation and output encoding to prevent common web vulnerabilities (e.g., XSS, SQLi) for {name}.")
            if el_type == "External Component":
                current_recommendations.append(f"Establish strict API security controls (authentication, authorization, rate limiting) for integration with {name}.")
                current_recommendations.append(f"Conduct third-party risk assessments for {name}.")
        elif domain == "Technology":
            current_recommendations.append(f"Implement principle of least privilege for {name}'s access controls.")
            current_recommendations.append(f"Ensure regular patching and vulnerability management for {name}.")
            if el_type == "Platform":
                if os_info:
                    current_recommendations.append(f"Apply OS hardening best practices for {os_info} on {name}.")
                    if "Linux" in os_info:
                        current_recommendations.append(f"Configure SSH with key-based authentication and disable root login for {name}.")
                    elif "Windows" in os_info:
                        current_recommendations.append(f"Ensure Windows firewall is enabled and configured correctly, and regularly apply Group Policies for {name}.")
                if ip_address:
                    current_recommendations.append(f"Implement network segmentation for {name} (IP: {ip_address}) to limit lateral movement.")
                    current_recommendations.append(f"Conduct port scanning on {ip_address} to identify unintended open ports.")
            elif el_type == "Network":
                current_recommendations.append(f"Regularly review and audit firewall rules for {name}.")
                current_recommendations.append(f"Implement Intrusion Detection/Prevention Systems (IDS/IPS) for network elements like {name}.")
                if ip_address:
                    current_recommendations.append(f"Ensure secure configuration and management of network device {name} (IP: {ip_address}).")
        elif domain == "Data":
            current_recommendations.append(f"Implement encryption for {name} at rest and in transit.")
            current_recommendations.append(f"Enforce strict access controls and data masking for sensitive data in {name}.")
            current_recommendations.append(f"Establish robust data backup and recovery procedures for {name}.")
            if "Database" in el_type:
                if os_info: # OS info here refers to DB type like PostgreSQL, MongoDB
                    current_recommendations.append(f"Apply database-specific hardening guides for {os_info} on {name}.")
        elif domain == "Business":
            current_recommendations.append(f"Provide security awareness training for users interacting with {name}.")
            current_recommendations.append(f"Define clear roles and responsibilities for security related to {name}.")

        # Recommendations based on criticality
        if criticality == "High":
            current_recommendations.append(f"Implement continuous monitoring and alerting for {name} to detect anomalies immediately.")
            current_recommendations.append(f"Conduct regular penetration tests and vulnerability assessments for {name}.")
            current_recommendations.append(f"Develop and regularly test a disaster recovery plan for {name}.")
        elif criticality == "Medium":
            current_recommendations.append(f"Perform periodic security reviews for {name}.")

        # Integrate existing threats into recommendations
        if threats:
            threat_list = [t.strip() for t in threats.split(',') if t.strip()]
            for threat in threat_list:
                if "SQL Injection" in threat:
                    current_recommendations.append(f"Mitigate SQL Injection risks by using parameterized queries/ORMs for {name}.")
                elif "XSS" in threat:
                    current_recommendations.append(f"Mitigate XSS risks by implementing strict output encoding for {name}.")
                elif "DDoS" in threat:
                    current_recommendations.append(f"Implement DDoS mitigation services (e.g., CDN, WAF) for {name}.")
                elif "Data breach" in threat:
                    current_recommendations.append(f"Strengthen data encryption and access controls to prevent data breaches for {name}.")
                elif "OS vulnerabilities" in threat and os_info:
                    current_recommendations.append(f"Prioritize patching critical {os_info} vulnerabilities on {name}.")

        # Filter out duplicates and add a note about existing requirements
        final_recommendations = list(set(current_recommendations))
        if existing_reqs:
            final_recommendations.insert(0, f"**Existing requirements for {name}:** {existing_reqs}")
        
        recommendations[name] = final_recommendations

    return recommendations

# --- Streamlit UI ---
st.set_page_config(layout="wide", page_title="Secure Architecture Modeler")

manager = SecurityArchitectureManager()

st.title("Secure Architecture Modeler")
st.markdown("Design your enterprise architecture and identify security requirements and threats.")
st.markdown("---")

# Sidebar for actions
with st.sidebar:
    st.header("Actions")
    selected_action = st.radio("Choose an action:", ["Define Architecture", "View Architecture", "Analyze Security"])

    st.markdown("---")
    st.header("Data Management")
    uploaded_file = st.file_uploader("Import Architecture (JSON)", type="json")
    if uploaded_file is not None:
        try:
            imported_data = json.load(uploaded_file)
            manager.import_data(imported_data)
            st.success("Architecture imported successfully!")
        except Exception as e:
            st.error(f"Error importing file: {e}")

    if st.button("Export Architecture (JSON)"):
        data_to_export = manager.get_all_data()
        st.download_button(
            label="Download Data",
            data=json.dumps(data_to_export, indent=4),
            file_name="security_architecture.json",
            mime="application/json"
        )

# --- Define Architecture Section ---
if selected_action == "Define Architecture":
    st.header("Define Architecture Elements")
    with st.form("element_form", clear_on_submit=True):
        col1, col2 = st.columns(2)
        with col1:
            name = st.text_input("Element Name", help="Unique name for the element (e.g., 'CRM System', 'HR Database').")
            domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], help="The ArchiMate layer this element belongs to.")
            el_type = st.text_input("Element Type (e.g., 'Actor', 'Application Component', 'Server', 'Database')", help="Specific type within the domain (e.g., 'Process', 'API', 'Firewall', 'User Database').")
            description = st.text_area("Description", help="Brief description of the element.")
        with col2:
            st.markdown("#### Security Details (Optional)")
            ip_address = st.text_input("IP Address (if applicable)", help="e.g., 192.168.1.10, 10.0.0.5")
            hostname = st.text_input("Hostname (if applicable)", help="e.g., webserver01, db-prod")
            os = st.text_input("Operating System/Technology (if applicable)", help="e.g., Ubuntu Server 22.04, Windows Server 2019, PostgreSQL, Cisco IOS")
            criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=1, help="Business criticality of this element.")
            security_requirements = st.text_area("Security Requirements (comma-separated)", help="Existing or proposed security controls (e.g., 'MFA', 'Encryption at Rest').")
            threats = st.text_area("Potential Threats (comma-separated)", help="Known or potential threats (e.g., 'SQL Injection', 'DDoS', 'Phishing').")

        submitted = st.form_submit_button("Add Element")
        if submitted:
            if name and domain and el_type and description:
                manager.add_element(name, domain, el_type, description, security_requirements, threats, ip_address, hostname, os, criticality)
            else:
                st.error("Please fill in Element Name, Domain, Type, and Description.")

    st.header("Manage Relationships")
    with st.form("relationship_form", clear_on_submit=True):
        elements_list = [el["name"] for el in manager.get_elements()]
        source = st.selectbox("Source Element", elements_list, key="rel_source")
        target = st.selectbox("Target Element", elements_list, key="rel_target")
        rel_type = st.text_input("Relationship Type (e.g., 'uses', 'accesses', 'hosts', 'protects')", help="Describes how elements interact.")
        rel_description = st.text_area("Relationship Description (Optional)")
        submitted_rel = st.form_submit_button("Add Relationship")
        if submitted_rel:
            if source and target and rel_type:
                manager.add_relationship(source, target, rel_type, rel_description)
            else:
                st.error("Please select source, target, and provide relationship type.")

    st.header("Edit/Delete Elements & Relationships")
    tab1, tab2, tab3 = st.tabs(["Edit Element", "Delete Element", "Delete Relationship"])

    with tab1:
        st.subheader("Edit Existing Element")
        elements_to_edit = manager.get_elements()
        element_names_to_edit = [el["name"] for el in elements_to_edit]
        selected_element_name = st.selectbox("Select Element to Edit", [""] + element_names_to_edit)

        if selected_element_name:
            selected_element_data = next((el for el in elements_to_edit if el["name"] == selected_element_name), None)
            if selected_element_data:
                with st.form("edit_element_form"):
                    new_name = st.text_input("New Element Name", value=selected_element_data["name"])
                    new_domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], index=["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"].index(selected_element_data["domain"]))
                    new_type = st.text_input("Element Type", value=selected_element_data["type"])
                    new_description = st.text_area("Description", value=selected_element_data["description"])
                    new_ip_address = st.text_input("IP Address", value=selected_element_data.get("ip_address", ""))
                    new_hostname = st.text_input("Hostname", value=selected_element_data.get("hostname", ""))
                    new_os = st.text_input("Operating System/Technology", value=selected_element_data.get("os", ""))
                    new_criticality_index = ["Low", "Medium", "High", "Critical"].index(selected_element_data.get("criticality", "Medium"))
                    new_criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=new_criticality_index)
                    new_security_requirements = st.text_area("Security Requirements (comma-separated)", value=selected_element_data["security_requirements"])
                    new_threats = st.text_area("Potential Threats (comma-separated)", value=selected_element_data["threats"])

                    edit_submitted = st.form_submit_button("Update Element")
                    if edit_submitted:
                        if new_name and new_domain and new_type and new_description:
                            manager.update_element(
                                selected_element_name,
                                new_name,
                                new_domain,
                                new_type,
                                new_description,
                                new_security_requirements,
                                new_threats,
                                new_ip_address,
                                new_hostname,
                                new_os,
                                new_criticality
                            )
                        else:
                            st.error("Please ensure all required fields are filled for update.")

    with tab2:
        st.subheader("Delete Element")
        elements_to_delete = [el["name"] for el in manager.get_elements()]
        element_to_delete = st.selectbox("Select Element to Delete", [""] + elements_to_delete)
        if st.button(f"Delete '{element_to_delete}'", disabled=not element_to_delete):
            manager.delete_element(element_to_delete)

    with tab3:
        st.subheader("Delete Relationship")
        relationships_data = manager.get_relationships()
        relationship_options = [
            f"{rel['source']} --({rel['type']})--> {rel['target']}" for rel in relationships_data
        ]
        selected_relationship_str = st.selectbox("Select Relationship to Delete", [""] + relationship_options)

        if selected_relationship_str:
            # Parse the selected string back to source, target, type
            parts = selected_relationship_str.split(" --(")
            source_del = parts[0].strip()
            type_and_target = parts[1].split("})-->")
            type_del = type_and_target[0].strip()
            target_del = type_and_target[1].strip()

            if st.button(f"Delete selected relationship"):
                manager.delete_relationship(source_del, target_del, type_del)


# --- View Architecture Section ---
elif selected_action == "View Architecture":
    st.header("Current Architecture Diagram")
    elements_data = manager.get_elements()
    relationships_data = manager.get_relationships()

    if elements_data:
        render_pyvis_graph(elements_data, relationships_data)
    else:
        st.info("No elements defined yet. Go to 'Define Architecture' to add elements.")

    st.header("Architecture Elements & Relationships List")
    st.subheader("Elements")
    df_elements = pd.DataFrame(elements_data)
    if not df_elements.empty:
        st.dataframe(df_elements)
    else:
        st.info("No elements to display.")

    st.subheader("Relationships")
    df_relationships = pd.DataFrame(relationships_data)
    if not df_relationships.empty:
        st.dataframe(df_relationships)
    else:
        st.info("No relationships to display.")

# --- Analyze Security Section ---
elif selected_action == "Analyze Security":
    st.header("Security Analysis & Recommendations")
    st.warning("Disclaimer: This 'AI Agent' provides *conceptual* security recommendations based on the defined architecture. It **does not** perform live penetration testing or active vulnerability scanning. For actual security assessments, consult specialized security tools and professionals.")

    elements_for_analysis = manager.get_elements()

    if st.button("Generate Security Recommendations"):
        if elements_for_analysis:
            st.subheader("Generated Recommendations:")
            recommendations = generate_security_recommendations(elements_for_analysis)
            for element_name, recs in recommendations.items():
                st.markdown(f"#### {element_name}")
                if recs:
                    for rec in recs:
                        st.markdown(f"- {rec}")
                else:
                    st.info("No specific recommendations generated for this element based on current data.")
            st.success("Recommendations generated!")
        else:
            st.info("No elements defined to generate recommendations for.")

    st.markdown("---")
    st.header("Current Threats & Requirements Overview")
    threat_data = []
    req_data = []

    for element in elements_for_analysis:
        if element["threats"]:
            for threat in [t.strip() for t in element["threats"].split(',') if t.strip()]:
                threat_data.append({"Element": element["name"], "Threat": threat, "Domain": element["domain"], "Criticality": element.get("criticality", "N/A")})
        if element["security_requirements"]:
            for req in [r.strip() for r in element["security_requirements"].split(',') if r.strip()]:
                req_data.append({"Element": element["name"], "Requirement": req, "Domain": element["domain"], "Criticality": element.get("criticality", "N/A")})

    st.subheader("Summarized Threats")
    df_threats = pd.DataFrame(threat_data)
    if not df_threats.empty:
        st.dataframe(df_threats)
    else:
        st.info("No threats defined yet.")

    st.subheader("Summarized Security Requirements")
    df_reqs = pd.DataFrame(req_data)
    if not df_reqs.empty:
        st.dataframe(df_reqs)
    else:
        st.info("No security requirements defined yet.")