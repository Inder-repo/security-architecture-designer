import streamlit as st
import sqlite3
from pyvis.network import Network
import streamlit.components.v1 as components
import pandas as pd
import json
from datetime import datetime # For dummy Jira ID

# --- Constants for ArchiMate-inspired styling ---
# More distinct colors and shapes
ARCHIMATE_NODE_PROPS = {
    "Strategy": {"color": "#8b0000", "shape": "diamond"}, # Darker red for Strategy
    "Business": {"color": "#008000", "shape": "box"},    # Darker green for Business
    "Application": {"color": "#00008b", "shape": "ellipse"}, # Darker blue for Application
    "Technology": {"color": "#800080", "shape": "triangle"}, # Purple for Technology
    "Physical": {"color": "#8b4513", "shape": "square"},  # Brown for Physical
    "Motivation": {"color": "#b8860b", "shape": "star"}, # Dark goldenrod for Motivation
    "Implementation & Migration": {"color": "#483d8b", "shape": "text"}, # Slate blue for I&M

    # Aspects - these might override or combine with layers based on specific element types
    # For simplicity, we mostly use layer colors, but shapes can be varied within layers
    "Active Structure": {}, # Default shape/color based on layer, maybe a specific border
    "Behavior": {},         # Default shape/color based on layer, maybe rounder corners if supported by Pyvis
    "Passive Structure": {},# Default shape/color based on layer
}

# Mapping for node shapes to distinguish aspects if needed, though colors for layers are primary
# Pyvis doesn't directly support ArchiMate's complex corner markings or inner icons without images.
# We'll use basic shapes, and colors for layers.
SHAPE_MAPPING = {
    "Actor": "box",
    "Process": "box",
    "Function": "box",
    "Service": "ellipse",
    "Data Object": "database",
    "System": "triangle",
    "Device": "square",
    "Network": "dot", # Simple dot for network
    "Platform": "diamond", # Represents infrastructure component
    "Requirement": "text",
    "Goal": "star",
    "Constraint": "text",
    "Capability": "diamond",
    "Resource": "hexagon",
    "Course of Action": "text",
    "Product": "box",
    "Contract": "text",
    "Location": "square",
    "Artifact": "circle",
    "Other": "dot" # Fallback
}

# --- Pre-defined GRC Standards and Controls ---
GRC_STANDARDS = {
    "NIST SP 800-53": {
        "AC-3": "Access Enforcement",
        "IA-2": "Identification and Authentication (Managed)",
        "SC-7": "Boundary Protection",
        "RA-5": "Vulnerability Monitoring and Scanning"
    },
    "ISO 27001": {
        "A.9.2.1": "Access control policy",
        "A.9.4.1": "Access control for information and information processing facilities",
        "A.13.1.1": "Network controls",
        "A.14.2.1": "Secure development policy"
    },
    "PCI DSS v4.0": {
        "2.2": "Develop and maintain security configuration standards",
        "8.2": "Authentication Management",
        "6.3": "Develop and maintain secure systems and software"
    }
}

# --- Database Manager ---
class SecurityArchitectureManager:
    def __init__(self, db_path="security_architecture.db"):
        self.db_path = db_path
        self._initialize_database_and_populate_if_empty()

    def _initialize_database_and_populate_if_empty(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS elements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                domain TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT,
                threats TEXT,
                ip_address TEXT,
                hostname TEXT,
                os TEXT,
                criticality TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS relationships (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source TEXT NOT NULL,
                target TEXT NOT NULL,
                type TEXT NOT NULL,
                description TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS security_requirements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                description TEXT NOT NULL UNIQUE,
                status TEXT NOT NULL DEFAULT 'Incomplete',
                jira_issue_id TEXT,
                grc_mappings TEXT, -- Stored as JSON string
                element_name TEXT, -- Links to the element this requirement applies to
                FOREIGN KEY (element_name) REFERENCES elements (name) ON DELETE CASCADE
            )
        ''')
        conn.commit()

        # Check if tables are empty and populate with sample data if they are
        cursor.execute("SELECT COUNT(*) FROM elements")
        if cursor.fetchone()[0] == 0:
            self._populate_sample_data(conn)
        conn.close()

    def _populate_sample_data(self, conn):
        cursor = conn.cursor()
        sample_elements = [
            ("Customer", "Business", "Actor", "External customer interacting with the system.", "Phishing, identity theft.", None, None, None, "High"),
            ("Online Store", "Application", "Application Component", "Web application for sales.", "SQL Injection, XSS, DDoS.", None, "onlinestore.example.com", "Linux/Nginx", "High"),
            ("Payment Gateway", "Application", "External Component", "Third-party payment processing service.", "Data breach, service unavailability.", None, "payment.gateway.com", None, "High"),
            ("Product Database", "Data", "Data Object", "Stores product information.", "Data tampering, unauthorized access.", None, None, "PostgreSQL", "Medium"),
            ("User Database", "Data", "Data Object", "Stores user profiles and credentials.", "Data breach, credential stuffing.", None, None, "MongoDB", "High"),
            ("Web Server", "Technology", "Platform", "Hosts the Online Store application.", "OS vulnerabilities, malware.", "192.168.1.10", "webserver01.example.com", "Ubuntu Server 22.04", "High"),
            ("Database Server", "Technology", "Platform", "Hosts product and user databases.", "Database vulnerabilities, data exfiltration.", "192.168.1.20", "dbserver01.example.com", "Windows Server 2019", "High"),
            ("Firewall", "Technology", "Network", "Protects the internal network.", "Misconfiguration, bypass.", "192.168.1.1", "main-firewall", "Palo Alto", "High"),
            ("Marketing Service", "Business", "Service", "Service for marketing campaigns.", "GDPR non-compliance, data leakage.", None, None, None, "Medium"),
            ("Load Balancer", "Technology", "Network", "Distributes traffic to web servers.", "Single point of failure, misconfiguration.", "192.168.1.5", "loadbalancer01.example.com", "HAProxy", "High")
        ]
        # Removed 'security_requirements' column from elements insert, as it's now in a separate table
        cursor.executemany("INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", sample_elements)

        sample_relationships = [
            ("Customer", "Online Store", "uses", "Customers use the online store."),
            ("Online Store", "Payment Gateway", "accesses", "Online store accesses payment gateway."),
            ("Online Store", "Product Database", "reads/writes", "Online store manages products."),
            ("Online Store", "User Database", "reads/writes", "Online store manages users."),
            ("Web Server", "Online Store", "hosts", "Web server hosts the online store app."),
            ("Database Server", "Product Database", "hosts", "DB server hosts product DB."),
            ("Database Server", "User Database", "hosts", "DB server hosts user DB."),
            ("Firewall", "Web Server", "protects", "Firewall protects web server."),
            ("Firewall", "Database Server", "protects", "Firewall protects database server."),
            ("Online Store", "Marketing Service", "notifies", "Online store notifies marketing for new customers."),
            ("Load Balancer", "Web Server", "routes traffic to", "Load Balancer routes traffic to web servers.")
        ]
        cursor.executemany("INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)", sample_relationships)

        sample_security_requirements = [
            ("Implement strong authentication for online store users.", "Online Store", "Incomplete", None, json.dumps(["NIST SP 800-53 IA-2", "ISO 27001 A.9.2.1"])),
            ("Encrypt sensitive data at rest in User Database.", "User Database", "Incomplete", None, json.dumps(["ISO 27001 A.9.4.1", "PCI DSS v4.0 2.2"])),
            ("Perform regular vulnerability scans on Web Server.", "Web Server", "Incomplete", None, json.dumps(["NIST SP 800-53 RA-5"])),
            ("Ensure PCI DSS compliance for Payment Gateway integration.", "Payment Gateway", "Incomplete", None, json.dumps(["PCI DSS v4.0 6.3"])),
            ("Implement WAF for Online Store.", "Online Store", "Incomplete", None, json.dumps(["NIST SP 800-53 SC-7"]))
        ]
        cursor.executemany("INSERT INTO security_requirements (description, element_name, status, jira_issue_id, grc_mappings) VALUES (?, ?, ?, ?, ?)", sample_security_requirements)

        conn.commit()
        conn.close()


    def get_elements(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Note: 'security_requirements' column is removed from elements table
        cursor.execute("SELECT name, domain, type, description, threats, ip_address, hostname, os, criticality FROM elements")
        elements = [{
            "name": row[0],
            "domain": row[1],
            "type": row[2],
            "description": row[3],
            "threats": row[4],
            "ip_address": row[5],
            "hostname": row[6],
            "os": row[7],
            "criticality": row[8]
        } for row in cursor.fetchall()]
        conn.close()
        return elements

    def get_relationships(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT source, target, type, description FROM relationships")
        relationships = [{"source": row[0], "target": row[1], "type": row[2], "description": row[3]} for row in cursor.fetchall()]
        conn.close()
        return relationships

    def add_element(self, name, domain, type, description, threats="", ip_address=None, hostname=None, os=None, criticality=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (name, domain, type, description, threats, ip_address, hostname, os, criticality)
            )
            conn.commit()
            st.success(f"Element '{name}' added successfully.")
        except sqlite3.IntegrityError:
            st.error(f"Element '{name}' already exists. Please choose a unique name.")
        finally:
            conn.close()

    def update_element(self, original_name, new_name, domain, type, description, threats, ip_address, hostname, os, criticality):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE elements SET name=?, domain=?, type=?, description=?, threats=?, ip_address=?, hostname=?, os=?, criticality=? WHERE name=?",
                (new_name, domain, type, description, threats, ip_address, hostname, os, criticality, original_name)
            )
            # Also update relationships and security requirements if the element name changed
            if original_name != new_name:
                cursor.execute("UPDATE relationships SET source=? WHERE source=?", (new_name, original_name))
                cursor.execute("UPDATE relationships SET target=? WHERE target=?", (new_name, original_name))
                cursor.execute("UPDATE security_requirements SET element_name=? WHERE element_name=?", (new_name, original_name))
            conn.commit()
            st.success(f"Element '{original_name}' updated to '{new_name}' successfully.")
        except sqlite3.IntegrityError:
            st.error(f"New name '{new_name}' already exists for another element. Please choose a unique name.")
        finally:
            conn.close()

    def delete_element(self, name):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # ON DELETE CASCADE for security_requirements table handles deletion of linked requirements
        cursor.execute("DELETE FROM elements WHERE name=?", (name,))
        cursor.execute("DELETE FROM relationships WHERE source=? OR target=?", (name, name))
        conn.commit()
        conn.close()
        st.success(f"Element '{name}' and its associated data deleted successfully.")

    def add_relationship(self, source, target, type, description=""):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Check if source and target elements exist
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (source,))
        source_exists = cursor.fetchone()
        cursor.execute("SELECT 1 FROM elements WHERE name=?", (target,))
        target_exists = cursor.fetchone()

        if source_exists and target_exists:
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (source, target, type, description)
            )
            conn.commit()
            st.success(f"Relationship '{source} {type} {target}' added successfully.")
        else:
            st.error("Source or target element does not exist. Please ensure both elements are defined.")
        conn.close()

    def delete_relationship(self, source, target, type):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM relationships WHERE source=? AND target=? AND type=?", (source, target, type))
        conn.commit()
        conn.close()
        st.success(f"Relationship '{source} {type} {target}' deleted successfully.")

    # --- Security Requirements Management ---
    def get_security_requirements(self, element_name=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        if element_name:
            cursor.execute("SELECT id, description, status, jira_issue_id, grc_mappings, element_name FROM security_requirements WHERE element_name=?", (element_name,))
        else:
            cursor.execute("SELECT id, description, status, jira_issue_id, grc_mappings, element_name FROM security_requirements")
        
        reqs = []
        for row in cursor.fetchall():
            grc_mappings = json.loads(row[4]) if row[4] else []
            reqs.append({
                "id": row[0],
                "description": row[1],
                "status": row[2],
                "jira_issue_id": row[3],
                "grc_mappings": grc_mappings,
                "element_name": row[5]
            })
        conn.close()
        return reqs

    def add_security_requirement(self, description, element_name, grc_mappings=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        grc_json = json.dumps(grc_mappings) if grc_mappings else "[]"
        try:
            cursor.execute(
                "INSERT INTO security_requirements (description, element_name, grc_mappings) VALUES (?, ?, ?)",
                (description, element_name, grc_json)
            )
            conn.commit()
            st.success(f"Security requirement '{description}' added.")
        except sqlite3.IntegrityError:
            st.error(f"Security requirement '{description}' already exists.")
        finally:
            conn.close()

    def toggle_security_requirement_status(self, req_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT status FROM security_requirements WHERE id=?", (req_id,))
        current_status = cursor.fetchone()[0]
        new_status = "Completed" if current_status == "Incomplete" else "Incomplete"
        cursor.execute("UPDATE security_requirements SET status=? WHERE id=?", (new_status, req_id))
        conn.commit()
        conn.close()
        st.success(f"Requirement status updated to {new_status}.")

    def link_jira_issue_to_requirement(self, req_id, jira_issue_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("UPDATE security_requirements SET jira_issue_id=? WHERE id=?", (jira_issue_id, req_id))
        conn.commit()
        conn.close()
        st.success(f"Jira issue '{jira_issue_id}' linked to requirement.")

    def delete_security_requirement(self, req_id):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM security_requirements WHERE id=?", (req_id,))
        conn.commit()
        conn.close()
        st.success("Security requirement deleted.")

    def get_all_data(self):
        elements = self.get_elements()
        relationships = self.get_relationships()
        security_requirements = self.get_security_requirements()
        return {"elements": elements, "relationships": relationships, "security_requirements": security_requirements}

    def import_data(self, data):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        # Clear existing data
        cursor.execute("DELETE FROM elements")
        cursor.execute("DELETE FROM relationships")
        cursor.execute("DELETE FROM security_requirements")

        # Insert new elements
        for el in data.get("elements", []):
            try:
                # Updated column list to match new elements table schema
                cursor.execute(
                    "INSERT INTO elements (name, domain, type, description, threats, ip_address, hostname, os, criticality) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    (el.get('name'), el.get('domain'), el.get('type'), el.get('description'), el.get('threats'), el.get('ip_address'), el.get('hostname'), el.get('os'), el.get('criticality'))
                )
            except sqlite3.IntegrityError:
                st.warning(f"Skipping import of element '{el.get('name')}' as it already exists (or name conflict).")
                continue
        # Insert new relationships
        for rel in data.get("relationships", []):
            cursor.execute(
                "INSERT INTO relationships (source, target, type, description) VALUES (?, ?, ?, ?)",
                (rel.get('source'), rel.get('target'), rel.get('type'), rel.get('description'))
            )
        # Insert new security requirements
        for req in data.get("security_requirements", []):
            grc_json = json.dumps(req.get('grc_mappings')) if req.get('grc_mappings') else "[]"
            cursor.execute(
                "INSERT INTO security_requirements (description, status, jira_issue_id, grc_mappings, element_name) VALUES (?, ?, ?, ?, ?)",
                (req.get('description'), req.get('status'), req.get('jira_issue_id'), grc_json, req.get('element_name'))
            )
        conn.commit()
        conn.close()
        st.success("Data imported successfully.")


# --- Helper function for visualization ---
def render_pyvis_graph(elements, relationships):
    net = Network(height="750px", width="100%", notebook=True, cdn_resources='remote',
                  heading="Security Architecture Diagram",
                  directed=True) # Ensure arrows for directed relationships

    # Add nodes
    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        description = element["description"]
        threats = element["threats"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os = element.get("os")
        criticality = element.get("criticality")

        color_props = ARCHIMATE_NODE_PROPS.get(domain, {"color": "#97C2FC", "shape": "box"})
        color = color_props.get("color")
        shape = SHAPE_MAPPING.get(el_type, "box") # Use specific shape, fallback to box

        title_html = f"<b>Name:</b> {name}<br>" \
                     f"<b>Domain:</b> {domain}<br>" \
                     f"<b>Type:</b> {el_type}<br>" \
                     f"<b>Description:</b> {description}<br>"

        if ip_address:
            title_html += f"<b>IP Address:</b> {ip_address}<br>"
        if hostname:
            title_html += f"<b>Hostname:</b> {hostname}<br>"
        if os:
            title_html += f"<b>OS:</b> {os}<br>"
        if criticality:
            title_html += f"<b>Criticality:</b> {criticality}<br>"

        title_html += f"<b>Threats:</b> {threats}" # Threats are still on element

        net.add_node(name, label=name, color=color, shape=shape, title=title_html)

    # Add edges
    for rel in relationships:
        source = rel["source"]
        target = rel["target"]
        rel_type = rel["type"]
        description = rel["description"]
        net.add_edge(source, target, title=description, label=rel_type, arrows='to')

    # Configure physics for better layout (optional, but often improves visualization)
    net.toggle_physics(True)
    net.set_edge_smooth('dynamic') # Adjusts edge curves for better readability

    # Generate HTML and display
    html_file = "architecture_graph.html"
    net.save_graph(html_file)
    with open(html_file, "r") as f:
        html_code = f.read()
    components.html(html_code, height=750)

# --- AI Agent for Security Recommendations (Conceptual) ---
def generate_security_recommendations(elements, security_requirements_data):
    recommendations = {}
    
    # Create a mapping of element name to its security requirements for quick lookup
    reqs_by_element = {}
    for req in security_requirements_data:
        element_name = req['element_name']
        if element_name not in reqs_by_element:
            reqs_by_element[element_name] = []
        reqs_by_element[element_name].append(req)

    for element in elements:
        name = element["name"]
        domain = element["domain"]
        el_type = element["type"]
        threats = element["threats"]
        ip_address = element.get("ip_address")
        hostname = element.get("hostname")
        os_info = element.get("os")
        criticality = element.get("criticality")

        current_recommendations = []
        
        # Add existing security requirements from the new table
        if name in reqs_by_element:
            existing_req_descriptions = [r['description'] for r in reqs_by_element[name]]
            current_recommendations.insert(0, f"**Existing requirements for {name}:** {'; '.join(existing_req_descriptions)}")
        

        # General recommendations based on domain/type
        if domain == "Application":
            current_recommendations.append(f"Perform regular security code reviews and static/dynamic application security testing (SAST/DAST) for {name}.")
            current_recommendations.append(f"Ensure proper input validation and output encoding to prevent common web vulnerabilities (e.g., XSS, SQLi) for {name}.")
            if el_type == "External Component":
                current_recommendations.append(f"Establish strict API security controls (authentication, authorization, rate limiting) for integration with {name}.")
                current_recommendations.append(f"Conduct third-party risk assessments for {name}.")
        elif domain == "Technology":
            current_recommendations.append(f"Implement principle of least privilege for {name}'s access controls.")
            current_recommendations.append(f"Ensure regular patching and vulnerability management for {name}.")
            if el_type == "Platform":
                if os_info:
                    current_recommendations.append(f"Apply OS hardening best practices for {os_info} on {name}.")
                    if "Linux" in os_info:
                        current_recommendations.append(f"Configure SSH with key-based authentication and disable root login for {name}.")
                    elif "Windows" in os_info:
                        current_recommendations.append(f"Ensure Windows firewall is enabled and configured correctly, and regularly apply Group Policies for {name}.")
                if ip_address:
                    current_recommendations.append(f"Implement network segmentation for {name} (IP: {ip_address}) to limit lateral movement.")
                    current_recommendations.append(f"Conduct port scanning on {ip_address} to identify unintended open ports.")
            elif el_type == "Network":
                current_recommendations.append(f"Regularly review and audit firewall rules for {name}.")
                current_recommendations.append(f"Implement Intrusion Detection/Prevention Systems (IDS/IPS) for network elements like {name}.")
                if ip_address:
                    current_recommendations.append(f"Ensure secure configuration and management of network device {name} (IP: {ip_address}).")
        elif domain == "Data":
            current_recommendations.append(f"Implement encryption for {name} at rest and in transit.")
            current_recommendations.append(f"Enforce strict access controls and data masking for sensitive data in {name}.")
            current_recommendations.append(f"Establish robust data backup and recovery procedures for {name}.")
            if "Database" in el_type:
                if os_info: # OS info here refers to DB type like PostgreSQL, MongoDB
                    current_recommendations.append(f"Apply database-specific hardening guides for {os_info} on {name}.")
        elif domain == "Business":
            current_recommendations.append(f"Provide security awareness training for users interacting with {name}.")
            current_recommendations.append(f"Define clear roles and responsibilities for security related to {name}.")

        # Recommendations based on criticality
        if criticality == "High":
            current_recommendations.append(f"Implement continuous monitoring and alerting for {name} to detect anomalies immediately.")
            current_recommendations.append(f"Conduct regular penetration tests and vulnerability assessments for {name}.")
            current_recommendations.append(f"Develop and regularly test a disaster recovery plan for {name}.")
        elif criticality == "Medium":
            current_recommendations.append(f"Perform periodic security reviews for {name}.")

        # Integrate existing threats into recommendations
        if threats:
            threat_list = [t.strip() for t in threats.split(',') if t.strip()]
            for threat in threat_list:
                if "SQL Injection" in threat:
                    current_recommendations.append(f"Mitigate SQL Injection risks by using parameterized queries/ORMs for {name}.")
                elif "XSS" in threat:
                    current_recommendations.append(f"Mitigate XSS risks by implementing strict output encoding for {name}.")
                elif "DDoS" in threat:
                    current_recommendations.append(f"Implement DDoS mitigation services (e.g., CDN, WAF) for {name}.")
                elif "Data breach" in threat:
                    current_recommendations.append(f"Strengthen data encryption and access controls to prevent data breaches for {name}.")
                elif "OS vulnerabilities" in threat and os_info:
                    current_recommendations.append(f"Prioritize patching critical {os_info} vulnerabilities on {name}.")

        # Filter out duplicates
        final_recommendations = list(set(current_recommendations))
        
        recommendations[name] = final_recommendations

    return recommendations

# --- Dummy Jira Integration Function ---
def create_jira_issue(req_description):
    """
    Placeholder for actual Jira API integration.
    In a real application, you would use a Jira client library (e.g., jira-python)
    to create an issue and return its key.
    """
    dummy_jira_id = f"SEC-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    st.info(f"Simulating Jira issue creation: '{dummy_jira_id}' for '{req_description}'")
    # Example using a hypothetical Jira client:
    # from jira import JIRA
    # jira = JIRA(server='https://your-jira-instance.atlassian.net', basic_auth=('user', 'api_token'))
    # issue = jira.create_issue(project='YOURPROJ', summary=req_description, description=f"Security Requirement: {req_description}", issuetype={'name': 'Task'})
    # return issue.key
    return dummy_jira_id

# --- Streamlit UI ---
st.set_page_config(layout="wide", page_title="Secure Architecture Modeler")

manager = SecurityArchitectureManager()

st.title("Secure Architecture Modeler")
st.markdown("Design your enterprise architecture and identify security requirements and threats.")
st.markdown("---")

# Sidebar for actions
with st.sidebar:
    st.header("Actions")
    selected_action = st.radio("Choose an action:", ["Define Architecture", "Manage Security Requirements", "View Architecture", "Analyze Security"])

    st.markdown("---")
    st.header("Data Management")
    uploaded_file = st.file_uploader("Import Architecture (JSON)", type="json")
    if uploaded_file is not None:
        try:
            imported_data = json.load(uploaded_file)
            manager.import_data(imported_data)
            st.success("Architecture imported successfully!")
            st.rerun() # Rerun to refresh the data display
        except Exception as e:
            st.error(f"Error importing file: {e}")

    if st.button("Export Architecture (JSON)"):
        data_to_export = manager.get_all_data()
        st.download_button(
            label="Download Data",
            data=json.dumps(data_to_export, indent=4),
            file_name="security_architecture.json",
            mime="application/json"
        )
    if st.button("Reset Database (Clear All Data)", help="Deletes all elements, relationships, and security requirements. Requires app restart."):
        if st.checkbox("Confirm reset? This cannot be undone."):
            os.remove(manager.db_path)
            st.warning("Database file removed. Please refresh your browser or restart Streamlit to re-initialize.")


# --- Define Architecture Section ---
if selected_action == "Define Architecture":
    st.header("Define Architecture Elements")
    with st.form("element_form", clear_on_submit=True):
        col1, col2 = st.columns(2)
        with col1:
            name = st.text_input("Element Name", help="Unique name for the element (e.g., 'CRM System', 'HR Database').")
            domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], help="The ArchiMate layer this element belongs to.")
            el_type = st.text_input("Element Type (e.g., 'Actor', 'Application Component', 'Server', 'Database')", help="Specific type within the domain (e.g., 'Process', 'API', 'Firewall', 'User Database').")
            description = st.text_area("Description", help="Brief description of the element.")
        with col2:
            st.markdown("#### Technical Details (Optional)") # Renamed for clarity as security reqs moved
            ip_address = st.text_input("IP Address (if applicable)", help="e.g., 192.168.1.10, 10.0.0.5")
            hostname = st.text_input("Hostname (if applicable)", help="e.g., webserver01, db-prod")
            os_info = st.text_input("Operating System/Technology (if applicable)", help="e.g., Ubuntu Server 22.04, Windows Server 2019, PostgreSQL, Cisco IOS")
            criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=1, help="Business criticality of this element.")
            threats = st.text_area("Potential Threats (comma-separated)", help="Known or potential threats (e.g., 'SQL Injection', 'DDoS', 'Phishing').")

        submitted = st.form_submit_button("Add Element")
        if submitted:
            if name and domain and el_type and description:
                manager.add_element(name, domain, el_type, description, threats, ip_address, hostname, os_info, criticality)
            else:
                st.error("Please fill in Element Name, Domain, Type, and Description.")

    st.header("Manage Relationships")
    with st.form("relationship_form", clear_on_submit=True):
        elements_list = [el["name"] for el in manager.get_elements()]
        if not elements_list:
            st.info("Please add elements before creating relationships.")
        else:
            source = st.selectbox("Source Element", elements_list, key="rel_source")
            target = st.selectbox("Target Element", elements_list, key="rel_target")
            rel_type = st.text_input("Relationship Type (e.g., 'uses', 'accesses', 'hosts', 'protects')", help="Describes how elements interact.")
            rel_description = st.text_area("Relationship Description (Optional)")
            submitted_rel = st.form_submit_button("Add Relationship")
            if submitted_rel:
                if source and target and rel_type:
                    manager.add_relationship(source, target, rel_type, rel_description)
                else:
                    st.error("Please select source, target, and provide relationship type.")

    st.header("Edit/Delete Elements & Relationships")
    tab1, tab2, tab3 = st.tabs(["Edit Element", "Delete Element", "Delete Relationship"])

    with tab1:
        st.subheader("Edit Existing Element")
        elements_to_edit = manager.get_elements()
        element_names_to_edit = [el["name"] for el in elements_to_edit]
        selected_element_name = st.selectbox("Select Element to Edit", [""] + element_names_to_edit, key="edit_element_select")

        if selected_element_name:
            selected_element_data = next((el for el in elements_to_edit if el["name"] == selected_element_name), None)
            if selected_element_data:
                with st.form("edit_element_form"):
                    new_name = st.text_input("New Element Name", value=selected_element_data["name"])
                    new_domain = st.selectbox("ArchiMate Domain/Layer", ["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"], index=["Business", "Application", "Technology", "Data", "Motivation", "Strategy", "Physical", "Implementation & Migration"].index(selected_element_data["domain"]))
                    new_type = st.text_input("Element Type", value=selected_element_data["type"])
                    new_description = st.text_area("Description", value=selected_element_data["description"])
                    new_ip_address = st.text_input("IP Address", value=selected_element_data.get("ip_address", ""))
                    new_hostname = st.text_input("Hostname", value=selected_element_data.get("hostname", ""))
                    new_os_info = st.text_input("Operating System/Technology", value=selected_element_data.get("os", ""))
                    new_criticality_index = ["Low", "Medium", "High", "Critical"].index(selected_element_data.get("criticality", "Medium"))
                    new_criticality = st.selectbox("Criticality", ["Low", "Medium", "High", "Critical"], index=new_criticality_index)
                    new_threats = st.text_area("Potential Threats (comma-separated)", value=selected_element_data["threats"])

                    edit_submitted = st.form_submit_button("Update Element")
                    if edit_submitted:
                        if new_name and new_domain and new_type and new_description:
                            manager.update_element(
                                selected_element_name,
                                new_name,
                                new_domain,
                                new_type,
                                new_description,
                                new_threats,
                                new_ip_address,
                                new_hostname,
                                new_os_info,
                                new_criticality
                            )
                            st.rerun()
                        else:
                            st.error("Please ensure all required fields are filled for update.")

    with tab2:
        st.subheader("Delete Element")
        elements_to_delete = [el["name"] for el in manager.get_elements()]
        element_to_delete = st.selectbox("Select Element to Delete", [""] + elements_to_delete, key="delete_element_select")
        if st.button(f"Delete '{element_to_delete}'", disabled=not element_to_delete, key="confirm_delete_element"):
            manager.delete_element(element_to_delete)
            st.rerun()

    with tab3:
        st.subheader("Delete Relationship")
        relationships_data = manager.get_relationships()
        relationship_options = [
            f"{rel['source']} --({rel['type']})--> {rel['target']}" for rel in relationships_data
        ]
        selected_relationship_str = st.selectbox("Select Relationship to Delete", [""] + relationship_options, key="delete_relationship_select")

        if selected_relationship_str:
            # Parse the selected string back to source, target, type
            parts = selected_relationship_str.split(" --(")
            source_del = parts[0].strip()
            type_and_target = parts[1].split("})-->")
            type_del = type_and_target[0].strip()
            target_del = type_and_target[1].strip()

            if st.button(f"Delete selected relationship", key="confirm_delete_relationship"):
                manager.delete_relationship(source_del, target_del, type_del)
                st.rerun()


# --- Manage Security Requirements Section (NEW) ---
elif selected_action == "Manage Security Requirements":
    st.header("Manage Security Requirements")

    elements_list = [el["name"] for el in manager.get_elements()]

    st.subheader("Add New Security Requirement")
    with st.form("add_security_req_form", clear_on_submit=True):
        req_description = st.text_area("Requirement Description", help="e.g., 'Implement MFA for administrative access to CRM System.'")
        
        if not elements_list:
            st.info("Please add architecture elements first to link requirements to them.")
            req_element_name = None
        else:
            req_element_name = st.selectbox("Applies to Element (Optional)", ["None"] + elements_list, help="Which architecture element this requirement primarily applies to.")
            if req_element_name == "None":
                req_element_name = None

        st.markdown("#### GRC Compliance Mapping")
        selected_grc_mappings = []
        for standard_name, controls in GRC_STANDARDS.items():
            st.markdown(f"**{standard_name}:**")
            cols = st.columns(3) # Display controls in 3 columns
            col_idx = 0
            for control_code, control_desc in controls.items():
                with cols[col_idx % 3]:
                    if st.checkbox(f"{control_code} - {control_desc}", key=f"grc_add_{standard_name}_{control_code}"):
                        selected_grc_mappings.append(f"{standard_name} {control_code}")
                col_idx += 1
        
        add_req_submitted = st.form_submit_button("Add Security Requirement")
        if add_req_submitted:
            if req_description:
                manager.add_security_requirement(req_description, req_element_name, selected_grc_mappings)
                st.rerun()
            else:
                st.error("Requirement description cannot be empty.")

    st.subheader("List of Security Requirements")
    security_requirements_data = manager.get_security_requirements()

    if not security_requirements_data:
        st.info("No security requirements defined yet.")
    else:
        # Create a DataFrame for display
        df_reqs = pd.DataFrame(security_requirements_data)
        
        # Add columns for actions
        df_reqs['Actions'] = ''
        df_reqs['Mark Completed'] = ''
        df_reqs['Link Jira'] = ''
        
        # Display as editable dataframe to allow checkboxes and buttons
        # Streamlit doesn't support direct checkboxes/buttons in dataframe cells easily.
        # We will iterate and create custom UI.

        for i, req in enumerate(security_requirements_data):
            col_id, col_desc, col_element, col_grc, col_jira, col_status, col_actions = st.columns([0.5, 4, 1.5, 2, 1.5, 1, 1.5])
            
            with col_id:
                st.write(req['id'])
            with col_desc:
                st.markdown(f"<span style='{'text-decoration: line-through;' if req['status'] == 'Completed' else ''}'>{req['description']}</span>", unsafe_allow_html=True)
            with col_element:
                st.markdown(f"**Element:** {req['element_name'] if req['element_name'] else 'Global'}")
            with col_grc:
                if req['grc_mappings']:
                    st.markdown("GRC: " + ", ".join(req['grc_mappings']))
                else:
                    st.write("No GRC mapped")
            with col_jira:
                if req['jira_issue_id']:
                    st.markdown(f"Jira: [`{req['jira_issue_id']}`](https://your-jira-instance.com/browse/{req['jira_issue_id']})") # Replace with your Jira base URL
                else:
                    st.write("No Jira")
            with col_status:
                st.write(req['status'])

            with col_actions:
                if st.button("Toggle Status", key=f"toggle_status_{req['id']}"):
                    manager.toggle_security_requirement_status(req['id'])
                    st.rerun()
                if not req['jira_issue_id'] and st.button("Create Jira", key=f"create_jira_{req['id']}"):
                    jira_id = create_jira_issue(req['description'])
                    if jira_id:
                        manager.link_jira_issue_to_requirement(req['id'], jira_id)
                        st.rerun()
                if st.button("Delete", key=f"delete_req_{req['id']}"):
                    manager.delete_security_requirement(req['id'])
                    st.rerun()
            st.markdown("---") # Separator for each requirement


# --- View Architecture Section ---
elif selected_action == "View Architecture":
    st.header("Current Architecture Diagram")
    elements_data = manager.get_elements()
    relationships_data = manager.get_relationships()

    if elements_data:
        render_pyvis_graph(elements_data, relationships_data)
    else:
        st.info("No elements defined yet. Go to 'Define Architecture' to add elements.")

    st.header("Architecture Elements & Relationships List")
    st.subheader("Elements")
    df_elements = pd.DataFrame(elements_data)
    if not df_elements.empty:
        st.dataframe(df_elements)
    else:
        st.info("No elements to display.")

    st.subheader("Relationships")
    df_relationships = pd.DataFrame(relationships_data)
    if not df_relationships.empty:
        st.dataframe(df_relationships)
    else:
        st.info("No relationships to display.")

# --- Analyze Security Section ---
elif selected_action == "Analyze Security":
    st.header("Security Analysis & Recommendations")
    st.warning("Disclaimer: This 'AI Agent' provides *conceptual* security recommendations based on the defined architecture. It **does not** perform live penetration testing or active vulnerability scanning. For actual security assessments, consult specialized security tools and professionals.")

    elements_for_analysis = manager.get_elements()
    security_requirements_for_analysis = manager.get_security_requirements() # Get all security requirements

    if st.button("Generate Security Recommendations"):
        if elements_for_analysis:
            st.subheader("Generated Recommendations:")
            recommendations = generate_security_recommendations(elements_for_analysis, security_requirements_for_analysis)
            for element_name, recs in recommendations.items():
                st.markdown(f"#### {element_name}")
                if recs:
                    for rec in recs:
                        st.markdown(f"- {rec}")
                else:
                    st.info("No specific recommendations generated for this element based on current data.")
            st.success("Recommendations generated!")
        else:
            st.info("No elements defined to generate recommendations for.")

    st.markdown("---")
    st.header("Current Threats & Requirements Overview")
    threat_data = []
    # security_requirements_data is already available from above

    for element in elements_for_analysis:
        if element["threats"]:
            for threat in [t.strip() for t in element["threats"].split(',') if t.strip()]:
                threat_data.append({"Element": element["name"], "Threat": threat, "Domain": element["domain"], "Criticality": element.get("criticality", "N/A")})
        
    st.subheader("Summarized Threats")
    df_threats = pd.DataFrame(threat_data)
    if not df_threats.empty:
        st.dataframe(df_threats)
    else:
        st.info("No threats defined yet.")

    st.subheader("Summarized Security Requirements")
    # Display the new security_requirements_data for summary, including GRC
    df_reqs_summary = pd.DataFrame(security_requirements_for_analysis)
    if not df_reqs_summary.empty:
        # Convert list of GRC mappings to a readable string for display
        df_reqs_summary['grc_mappings'] = df_reqs_summary['grc_mappings'].apply(lambda x: ", ".join(x) if x else "N/A")
        st.dataframe(df_reqs_summary[['id', 'description', 'element_name', 'status', 'jira_issue_id', 'grc_mappings']])
    else:
        st.info("No security requirements defined yet.")